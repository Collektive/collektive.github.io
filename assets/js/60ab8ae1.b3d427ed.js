"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[6055],{8288:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"introduction/aggregate-programming","title":"Aggregate Programming and Field Calculus","description":"The progressive increase in the number of interconnected devices, leads to a rise in the costs associated with maintaining distributed systems. This creates significant challenges in implementing software services on a global scale using the traditional approach of individually programming each agent. This situation drives the search for solutions aimed at improving the autonomy of computing systems and reducing their complexity.","source":"@site/docs/introduction/aggregate-programming.mdx","sourceDirName":"introduction","slug":"/introduction/aggregate-programming","permalink":"/docs/introduction/aggregate-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/Collektive/collektive/tree/master/site/docs/introduction/aggregate-programming.mdx","tags":[],"version":"current","frontMatter":{"title":"Aggregate Programming and Field Calculus"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/category/introduction"},"next":{"title":"What is Collektive?","permalink":"/docs/introduction/what-is-collektive"}}');var r=i(4848),o=i(8453);const a={title:"Aggregate Programming and Field Calculus"},s="The Challenge of Maintaining Distributed Systems",l={},c=[{value:"Aggregate Programming as a Relevant Approach",id:"aggregate-programming-as-a-relevant-approach",level:2},{value:"Key Properties of Aggregate Programming",id:"key-properties-of-aggregate-programming",level:3},{value:"Practical Applications of Aggregate Programming",id:"practical-applications-of-aggregate-programming",level:3},{value:"Levels of Abstraction in Aggregate Programming",id:"levels-of-abstraction-in-aggregate-programming",level:2},{value:"Field Calculus Constructs",id:"field-calculus-constructs",level:3},{value:"Resilient Coordination Operators",id:"resilient-coordination-operators",level:3},{value:"Developer APIs",id:"developer-apis",level:3},{value:"Example: Gradient Computation",id:"example-gradient-computation",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"the-challenge-of-maintaining-distributed-systems",children:"The Challenge of Maintaining Distributed Systems"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"progressive increase"})," in the number of interconnected devices, leads to a ",(0,r.jsx)(n.strong,{children:"rise in the costs"})," associated with maintaining distributed systems. This creates ",(0,r.jsx)(n.strong,{children:"significant challenges"})," in implementing software services on a ",(0,r.jsx)(n.strong,{children:"global scale"})," using the traditional approach of individually programming each agent. This situation drives the search for solutions aimed at improving the ",(0,r.jsx)(n.strong,{children:"autonomy"})," of computing systems and ",(0,r.jsx)(n.strong,{children:"reducing their complexity"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"aggregate-programming-as-a-relevant-approach",children:"Aggregate Programming as a Relevant Approach"}),"\n",(0,r.jsxs)(n.p,{children:["In this context, ",(0,r.jsx)(n.strong,{children:"Aggregate Programming"}),(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," (AP) emerges as a ",(0,r.jsx)(n.strong,{children:"relevant macroprogramming approach"}),". It is based on the ",(0,r.jsx)(n.strong,{children:"functional composition"})," of ",(0,r.jsx)(n.strong,{children:"reusable collective behavior blocks"}),", with the goal of efficiently achieving ",(0,r.jsx)(n.strong,{children:"complex"})," and ",(0,r.jsx)(n.strong,{children:"resilient behaviors"})," in ",(0,r.jsx)(n.strong,{children:"dynamic networks"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"key-properties-of-aggregate-programming",children:"Key Properties of Aggregate Programming"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Self-organization"}),": the system as a whole is capable of achieving globally coordinated behaviors through decentralized interactions among individual devices.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Self-coordination"}),": devices autonomously exchange information and adapt their behavior to maintain coherence, even in the absence of centralized control;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Self-stabilization"}),": the system naturally converges to a desired stable state despite transient disruptions or changes in the network."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resilience"}),": the system is inherently robust to node failures, dynamic topology changes, and unpredictable environmental conditions (e.g., wireless interference, sudden weather changes affecting sensor networks, or physical obstacles disrupting communication), ensuring continued functionality under adverse circumstances."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": the system can efficiently handle a growing number of devices while maintaining low communication overhead and computational efficiency. As the network size increases, the system continues to provide predictable response times and stable resource consumption, ensuring overall performance in terms of latency, throughput, and fault tolerance."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Aggregate programming finds its conceptual roots in ",(0,r.jsx)(n.strong,{children:"Field Calculus"}),(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"(FC), a minimal functional programming language designed for the specification and composition of collective behaviors. FC provides a formal framework for expressing distributed algorithms in terms of computational fields, enabling concise and declarative descriptions of large-scale system behaviors."]}),"\n",(0,r.jsxs)(n.p,{children:["Building on this foundation, Aggregate Programming defines ",(0,r.jsx)(n.strong,{children:"basic building blocks"}),", which serve as foundational mechanisms for collective behavior."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.strong,{children:"broadcasting"})," and ",(0,r.jsx)(n.strong,{children:"gradient formation"})," are widely applied in sensor networks to propagate information efficiently."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Event detection"})," and ",(0,r.jsx)(n.strong,{children:"consensus"})," play a crucial role in distributed monitoring systems, enabling nodes to agree on the occurrence of specific conditions despite local disruptions."]}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, ",(0,r.jsx)(n.strong,{children:"clustering"})," and ",(0,r.jsx)(n.strong,{children:"leader election"})," are essential in ad-hoc mobile networks to establish hierarchical structures and coordinate actions."]}),"\n",(0,r.jsx)(n.p,{children:"These building blocks lay the groundwork for more advanced and resilient applications across dynamic and large-scale environments."}),"\n",(0,r.jsx)(n.h3,{id:"practical-applications-of-aggregate-programming",children:"Practical Applications of Aggregate Programming"}),"\n",(0,r.jsx)(n.p,{children:"Aggregate Programming has demonstrated its versatility in solving complex coordination problems in distributed systems. Practical use cases include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robot Swarms"}),(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-4",id:"user-content-fnref-4","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),": AP enables coordinated behavior in fleets of autonomous robot, such as formation control, coverage, and search-and-rescue operations, where dynamic and resilient coordination is required."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Crowd Management"}),(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),": AP supports applications for monitoring and controlling crowds, including density estimation, anomaly detection, and safe dispersal strategies in large-scale events or emergency scenarios."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environmental Monitoring"}),": sensor networks employing AP can collectively estimate parameters like pollution levels, temperature gradients, or wildfire spread by aggregating local measurements efficiently."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vascular Morphogenesis"}),(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),": an early application of AP was demonstrated in the context of vascular morphogenesis, where Collektive was used to model self-organizing biological patterns."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These examples highlight how Aggregate Programming simplifies the design and implementation of robust, scalable, and adaptive behaviors in dynamic and decentralized systems."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"levels-of-abstraction-in-aggregate-programming",children:"Levels of Abstraction in Aggregate Programming"}),"\n",(0,r.jsx)(n.p,{children:"Through multiple levels of abstraction, aggregate programming mitigates the complexity involved in distributed coordination within IoT network environments:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Aggregated levels of abstraction in aggregate programming",src:i(4463).A+"",width:"1138",height:"796"})}),"\n",(0,r.jsx)(n.h3,{id:"field-calculus-constructs",children:"Field Calculus Constructs"}),"\n",(0,r.jsx)(n.p,{children:"This layer represents the interface where aggregate programming interacts with the external environment. It is composed of device infrastructure and non-aggregated software services, which together form the system's lowest layer. As depicted in the figure, this is the second layer from the bottom."}),"\n",(0,r.jsxs)(n.p,{children:["A key abstraction provided by ",(0,r.jsx)(n.strong,{children:"Field Calculus"})," is the notion of a ",(0,r.jsx)(n.em,{children:"field"}),", inspired by physical phenomena."]}),"\n",(0,r.jsx)(n.p,{children:"In this abstraction, each networked device contributes a local value, forming a distributed structure over the system."}),"\n",(0,r.jsx)(n.p,{children:"For example, temperature sensors might define a field of ambient temperature values, while smartphones might contribute fields of movement directions or displayed notifications."}),"\n",(0,r.jsx)(n.p,{children:"Field manipulation and creation rely on fundamental constructs that enable:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Computation over distributed data"}),": functions allow the execution of operations on data distributed across the system, including both built-in and user-defined logic. These computations can represent readings from sensors or outputs to actuators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State evolution over time"}),": mechanisms are provided to model how a device's local state evolves, based on previous states and new inputs from the environment or the system."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interaction with neighbors"}),": constructs enable devices to collect and aggregate information from neighboring devices, supporting spatial computations like detecting the closest node or propagating values across the network. Notably, value propagation requires a combination of state management mechanisms (for maintaining state across computation rounds) and neighbor interaction constructs (for accessing neighbors' values), enabling the definition of distributed algorithms such as gradient formation or information spreading."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conditional branching in the network"}),": conditional mechanisms allow devices to behave differently based on local or global conditions, partitioning the network into distinct regions that execute different operations."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Together, these constructs enable the creation of robust and flexible behaviors that emerge from the aggregation of local device interactions and computations."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"resilient-coordination-operators",children:"Resilient Coordination Operators"}),"\n",(0,r.jsxs)(n.p,{children:["The next level of abstraction introduces a set of ",(0,r.jsx)(n.strong,{children:"resilient coordination operators"})," designed for robust distributed computations."]}),"\n",(0,r.jsx)(n.p,{children:"These operators enable the system to adapt reactively to changes in network structure or input values, ensuring self-stabilization and resilience."}),"\n",(0,r.jsx)(n.p,{children:"Key operators include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gradient formation and value propagation"}),": operations that calculate distance fields and propagate values across the network based on these gradients. These operators are crucial for tasks like broadcasting, projection, or region-based computations, where spatial relationships between nodes are important."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cumulative information gathering"}),": mechanisms for aggregating information along gradients, such as summing values or collecting information towards specific regions of interest."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible temporal decay"}),": constructs that manage countdown processes or decay functions, enabling time-based coordination that adapts to changing rates or conditions."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These operators abstract common coordination patterns, simplifying the development of distributed applications by allowing developers to focus on high-level behavior and global objectives, rather than low-level implementation details."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"developer-apis",children:"Developer APIs"}),"\n",(0,r.jsxs)(n.p,{children:["Libraries developed using fundamental operators can leverage and combine these operators to create a pragmatic and user-friendly ",(0,r.jsx)(n.strong,{children:"API"})," (Application Programming Interface). These libraries represent the penultimate layer in the structure illustrated in the figure, on which application code is based."]}),"\n",(0,r.jsx)(n.p,{children:"Many distributed actions and information diffusion processes can be abstracted into high-level API functions that encapsulate the complexity of the underlying coordination logic."}),"\n",(0,r.jsx)(n.h4,{id:"example-gradient-computation",children:"Example: Gradient Computation"}),"\n",(0,r.jsxs)(n.p,{children:["The following example demonstrates a simple API function for computing a ",(0,r.jsx)(n.strong,{children:"distance gradient"}),". This function calculates the minimum distance from a set of source devices within a dynamic network. Gradients are a foundational construct in aggregate programming, enabling behaviors like distance estimation and value propagation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": when defining new aggregate functions, it is recommended to use extension functions on the aggregate interface. This promotes reusability and consistency as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"fun Aggregate<Int>.gradient(distanceSensor: DistanceSensor, source: Boolean): Double =\n    share(POSITIVE_INFINITY) {\n        val dist = distances()\n        when {\n            source -> 0.0\n            else -> (it + dist).min(POSITIVE_INFINITY)\n        }\n    }\n"})}),"\n",(0,r.jsx)(n.p,{children:"These APIs enable developers to implement sophisticated behaviors within dynamic networks without needing to delve into the low-level details of aggregate computations."}),"\n","\n",(0,r.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,r.jsxs)(n.p,{children:["J. Beal, D. Pianini, and M. Viroli, \u201cAggregate Programming for the Internet of Things,\u201d Computer, vol. 48, no. 9, pp. 22\u201330, 2015, doi: 10.1109/MC.2015.261. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-3",children:["\n",(0,r.jsxs)(n.p,{children:["G. Audrito, J. Beal, F. Damiani, and M. Viroli, \u201cSpace-Time Universality of Field Calculus\u201d, in Coordination Models and Languages, 2018, pp. 1\u201320. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-3","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-4",children:["\n",(0,r.jsxs)(n.p,{children:["G. Aguzzi, G. Audrito, R. Casadei, F. Damiani, G. Torta, and M. Viroli, \u201cA field-based computing approach to sensing-driven clustering in robot swarms,\u201d Swarm Intelligence, vol. 17, no. 1\u20132, pp. 27\u201362, Sep. 2022, doi: 10.1007/s11721-022-00215-y. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-4","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-5",children:["\n",(0,r.jsxs)(n.p,{children:["B. Anzengruber, D. Pianini, J. Nieminen, and A. Ferscha, \u201cPredicting Social Density in Mass Events to Prevent Crowd Disasters,\u201d Lecture notes in computer science, pp. 206\u2013215, Jan. 2013, doi: 10.1007/978-3-319-03260-3_18. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-5","data-footnote-backref":"","aria-label":"Back to reference 4",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,r.jsxs)(n.p,{children:["A. Cortecchia, D. Pianini, G. Ciatto, and R. Casadei, \u201cAn Aggregate Vascular Morphogenesis Controller for Engineered Self-Organising Spatial Structures,\u201d in 2024 IEEE International Conference on Autonomic Computing and Self-Organizing Systems (ACSOS), 2024, pp. 133\u2013138. doi: 10.1109/ACSOS61780.2024.00032. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 5",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},4463:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/multiple-levels-of-abstraction-ag-409b85b6e9cccbba522802b48ad0492e.png"},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var t=i(6540);const r={},o=t.createContext(r);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);