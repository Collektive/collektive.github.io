"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2945],{1738:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"tutorials/basic-usage","title":"Basic Usage","description":"The library function neighboring is a aggregate operator and is used to observe the value of an expression [local] across neighboring nodes.","source":"@site/docs/tutorials/basic-usage.mdx","sourceDirName":"tutorials","slug":"/tutorials/basic-usage","permalink":"/docs/tutorials/basic-usage","draft":false,"unlisted":false,"editUrl":"https://github.com/Collektive/collektive/tree/master/site/docs/tutorials/basic-usage.mdx","tags":[],"version":"current","frontMatter":{"title":"Basic Usage"},"sidebar":"tutorialSidebar","previous":{"title":"Tutorial","permalink":"/docs/category/tutorial"},"next":{"title":"Using Collektive with Alchemist Simulator","permalink":"/docs/tutorials/collektive-and-alchemist"}}');var i=t(4848),s=t(8453);const o={title:"Basic Usage"},r=void 0,c={},l=[{value:"Example",id:"example",level:2},{value:"First part",id:"first-part",level:3},{value:"Second part",id:"second-part",level:3},{value:"Third part",id:"third-part",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"/**\n * Function to evaluate the number of neighbors of a node in an [Aggregate] context.\n */\nfun Aggregate<Int>.neighborCounter(): Int = neighboring(1).count()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The library function ",(0,i.jsx)(n.a,{href:"/docs/tutorials/dsl-descriptions?search=neighboring",children:"neighboring"})," is a ",(0,i.jsx)(n.strong,{children:"aggregate operator"})," and is used to observe the value of an expression [local] across neighboring nodes."]}),"\n",(0,i.jsxs)(n.p,{children:["The returned field has as its local value the value passed as input (1 in this example). Using the ",(0,i.jsx)(n.a,{href:"/docs/tutorials/dsl-descriptions?search=count",children:"count"})," function, you count the values \u200b\u200bin the field, thus obtaining the number of neighbors of a node."]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.h3,{id:"first-part",children:"First part"}),"\n",(0,i.jsx)(n.p,{children:"This first part code demonstrates how devices, through mutual communication, are able to identify the maximum ID among the neighboring nodes within their local network area (neighborhood):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"/**\n * Identify the maximum ID values among the neighboring nodes.\n*/\n\nfun Aggregate<Int>.maxNeighborID(environment: EnvironmentVariables): Int {\n    // Step 1: Exchange the localId with neighbors and obtain a field of values\n    val neighborValues = neighboring(local = localId)\n\n    // Step 2: Find the maximum value among neighbors (including self)\n    val maxValue = neighborValues.max(base = localId)\n\n    return maxValue\n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.a,{href:"/docs/tutorials/dsl-descriptions?search=max",children:"max"})," function the maximum value of a field that includes the local value of the node is identified."]}),"\n",(0,i.jsx)(n.h3,{id:"second-part",children:"Second part"}),"\n",(0,i.jsx)(n.p,{children:"This second part represents a variation of the previous one. Building upon the local maximum computation introduced in the first part, the code presented here extends the process through a second layer of communication among nodes, enabling convergence toward the global maximum of the network."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"/**\n * Identify the maximum ID values in the network.\n*/\n\nfun Aggregate<Int>.maxNetworkID(environment: EnvironmentVariables): Int {\n    val maxLocalValue = maxNeighborID()\n\n    // Step 1: Exchange the maxNeighborID with neighbors and obtain a field of values\n    val neighborValues = neighboring(local = maxLocalValue)\n\n    // Step 2: Find the maximum value among neighbors (including self)\n    val maxValue = neighborValues.max(base = maxLocalValue)\n    \n    return maxValue\n}\n\n// Function of the previous part\nfun Aggregate<Int>.maxNeighborID(): Int {\n    val neighborValues = neighboring(local = localId)\n    val maxValue = neighborValues.max(base = localId)\n    return maxValue\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This second part illustrates a variant of leader election implemented with Collektive."}),"\n",(0,i.jsx)(n.p,{children:"Specifically, in this first two part, the use of aggregated operators and operations on the neighborhood field is analyzed."}),"\n",(0,i.jsx)(n.h3,{id:"third-part",children:"Third part"}),"\n",(0,i.jsx)(n.p,{children:"In this final part, we extend the previous exercise by considering dividing the network into multiple subnets. The goal is to determine the diameter in relation to the source, which corresponds to the maximum value of the subnetworks."}),"\n",(0,i.jsx)(n.p,{children:"In other words, we aim to find the maximum distance (measured in terms of hops) from a non-source node to the nearest source node. The source nodes are those with the highest ID values in the network, and each source node identifies a separate subnetwork."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"/**\n * Determine the diameter of the subnetworks corresponding to the nodes with the maximum ID values in the network of the last exercise.\n*/\n\n// Preliminary step: define a data class to represent the association between a source node and its distance\ndata class SourceDistance(val sourceID: Int, val distance: Int)\n\nfun Aggregate<Int>.subnetdiameter(sourceID: Int, distanceToSource: Int): SourceDistance {\n    // Step 1: retrieve the distances from neighboring nodes, including the distance of the current node\n    val distances = neighboring(SourceDistance(sourceID, distanceToSource))\n\n    // Step 2: find the neighbor with the maximum distance for the given sourceID\n    return distances.maxBy(SourceDistance(sourceID, distanceToSource)){ \n\n        // If the sourceID matches, return the actual distance; otherwise, Int.MIN_VALUE is used to exclude it\n        if(sourceID == it.sourceID) it.distance else Int.MIN_VALUE \n    }\n}\n\nfun Aggregate<Int>.maxNetworkID(environment: EnvironmentVariables): Int {\n    \n    ...\n\n    // Preliminary step: the distance from the nearest source is calculated using the hopDistanceTo library function \n    distanceToSource = hopDistanceTo(localId == maxValue)\n\n    // Calculate subnets diameter \n    val subnetDiameterValue = subnetdiameter(maxValue, distanceToSource).distance\n\n    ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/docs/tutorials/dsl-descriptions?search=maxBy",children:"maxBy"})," function is a variant of the max function (used in previous parts) that calculates the maximum value in the field according to specifications. In particular, in this part, maxBy is used to specify towards which source the shared distance has been calculated. In such a way as to count in the identification of the maximum only the distances towards a specific source."]}),"\n",(0,i.jsxs)(n.p,{children:["The distance in terms of hops to the nearest source is calculated using the ",(0,i.jsx)(n.a,{href:"/docs/tutorials/stdlib-descriptions?search=hopDistanceTo",children:"hopDistanceTo"})," function."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(6540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);