"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[6168],{8046:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"tutorials/first-collektive-program","title":"First Collektive Program","description":"Device Counter","source":"@site/docs/tutorials/first-collektive-program.mdx","sourceDirName":"tutorials","slug":"/tutorials/first-collektive-program","permalink":"/docs/tutorials/first-collektive-program","draft":false,"unlisted":false,"editUrl":"https://github.com/Collektive/collektive/tree/master/site/docs/tutorials/first-collektive-program.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"First Collektive Program","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Getting Started","permalink":"/docs/tutorials/gettingstarted"},"next":{"title":"Basic Usage","permalink":"/docs/tutorials/basic-usage"}}');var o=n(4848),s=n(8453);const r={title:"First Collektive Program",sidebar_position:2},c=void 0,l={},a=[{value:"Device Counter",id:"device-counter",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h3,{id:"device-counter",children:"Device Counter"}),"\n",(0,o.jsxs)(t.p,{children:["Let's create a program where ",(0,o.jsx)(t.em,{children:"each device"})," learns the total number of devices in the network."]}),"\n",(0,o.jsxs)(t.p,{children:["We can use the ",(0,o.jsx)(t.a,{href:"https://javadoc.io/doc/it.unibo.collektive/collektive-stdlib/latest/collektive-stdlib/it.unibo.collektive.stdlib.accumulation/count-devices.html",children:"countDevices"}),"\nfunction from the standard library,\nwhich relies on a ",(0,o.jsx)(t.a,{href:"https://javadoc.io/doc/it.unibo.collektive/collektive-stdlib/latest/collektive-stdlib/it.unibo.collektive.stdlib.spreading/hop-distance-to.html",children:"hopDistance"})," metric.\nThis function is based on the ",(0,o.jsx)(t.a,{href:"https://javadoc.io/doc/it.unibo.collektive/collektive-stdlib/latest/collektive-stdlib/it.unibo.collektive.stdlib.accumulation/converge-cast.html",children:"convergeCast"})," operation,\nwhich aggregates values towards the root device in the network."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-kotlin",metastring:"file=<rootDir>/static/code/FirstCollektiveProgram.kt#L1-L7",children:"/**\n * Count the number of devices in the network.\n * The total is accumulated in the device with [localId] 0 (the [sink]).\n * Other devices hold the number of devices in their subtree towards the network edge, inlcuding themselves.\n * A leaf node (with no outward neighbors) will hold 1.\n */\nfun Aggregate<Int>.countDevicesEntrypoint(): Int = countDevices(sink = localId == 0)\n"})}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"With our goal in mind,\nthis implementation has a limitation: only the root device will know the number of devices in the network."})}),"\n",(0,o.jsxs)(t.p,{children:["We now need to propagate the information accumulated by the root device to all other devices in the network.\nHow?\nBy broadcasting the value with the ",(0,o.jsx)(t.a,{href:"https://javadoc.io/doc/it.unibo.collektive/collektive-stdlib/latest/collektive-stdlib/it.unibo.collektive.stdlib.spreading/gradient-cast.html",children:"gradientCast"})," function,\nwhich propagates it across multiple spanning trees,\nstarting from the root."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-kotlin",metastring:"file=<rootDir>/static/code/FirstCollektiveProgram.kt#L9-L18",children:"/**\n * Broadcast from the [source] the number of devices connected to the network.\n * Requires a [distances] field to be used as metric for computing the distance from the source to the target.\n */\nfun Aggregate<Int>.broadcastCountDevices(distances: Field<Int, Double>, source: Boolean): Int =\n    gradientCast(\n        metric = distances,\n        source = source,\n        local = countDevices(sink = source),\n    )\n"})}),"\n",(0,o.jsx)(t.p,{children:"The following is the program that each device will execute:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-kotlin",metastring:"file=<rootDir>/static/code/FirstCollektiveProgram.kt#L20-L30",children:"/**\n * [collektiveDevice] represents the device running the Collektive program.\n * It is used to access the device's properties and methods,\n * such as the [distances] method, which returns a field of distances from the neighboring nodes.\n * In this case, the source is the device with [localId] equal to 0.\n */\nfun Aggregate<Int>.broadcastCountDevicesEntrypoint(collektiveDevice: CollektiveDevice<*>): Int =\n    broadcastCountDevices(\n        distances = with(collektiveDevice) { distances() },\n        source = localId == 0,\n    )\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now all the devices in the network will know how many devices are currently connected."}),"\n",(0,o.jsx)(t.admonition,{type:"caution",children:(0,o.jsx)(t.p,{children:"What happens if a group of devices or the root gets disconnected from the network,\nor the network becomes segmented?"})}),"\n",(0,o.jsx)(t.p,{children:"In such a case,\nthe subnetwork that still contains the root device will continue to compute the updated number of devices.\nHowever,\nany subnetworks that no longer include the root will not be able to do so."}),"\n",(0,o.jsxs)(t.p,{children:["How can we address this issue?\nWe can use a ",(0,o.jsx)(t.strong,{children:"leader election algorithm"}),",\nwhich allows us to dynamically elect a new root device within each connected component of the network.\nIn this tutorial,\nwe use the ",(0,o.jsx)(t.a,{href:"https://javadoc.io/doc/it.unibo.collektive/collektive-stdlib/latest/collektive-stdlib/it.unibo.collektive.stdlib.consensus/bounded-election.html",children:"boundedElection"})," function from the standard library."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-kotlin",metastring:"file=<rootDir>/static/code/FirstCollektiveProgram.kt#L32-L44",children:"/**\n * Counts and broadcast the number of devices in the network using a leader election.\n * If the network is segmented, each connected component elects a leader to act as root.\n */\nfun Aggregate<Int>.broadcastCountDevicesWithLeaderElectionEntrypoint(\n    collektiveDevice: CollektiveDevice<*>,\n): Int {\n    val leaderId = boundedElection(bound)\n    return broadcastDevices(\n        distances = with(collektiveDevice) { distances() },\n        source = localId == leaderId,\n    )\n}\n"})}),"\n",(0,o.jsx)(t.admonition,{title:"Success",type:"tip",children:(0,o.jsx)(t.p,{children:"Now we're all set!\nThe final program will recompute the number of devices in the network, even if the network becomes segmented."})}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["The code above can be found and executed in the ",(0,o.jsx)(t.a,{href:"https://github.com/Collektive/collektive-examples/blob/master/simulation/src/main/kotlin/it/unibo/collektive/examples/counter/Counter.kt",children:"collektive examples repository"}),"."]})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);