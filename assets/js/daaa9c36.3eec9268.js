"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[5995],{8572:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"explanation/levels-of-abstractions","title":"Levels of Abstraction in Aggregate Programming","description":"Levels of Abstraction in Aggregate Programming","source":"@site/docs/explanation/levels-of-abstractions.mdx","sourceDirName":"explanation","slug":"/explanation/levels-of-abstractions","permalink":"/docs/explanation/levels-of-abstractions","draft":false,"unlisted":false,"editUrl":"https://github.com/Collektive/collektive/tree/master/site/docs/explanation/levels-of-abstractions.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Levels of Abstraction in Aggregate Programming","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Building Resilient Systems with Aggregate Programming","permalink":"/docs/explanation/aggregate-programming"},"next":{"title":"Fields and Basic Aggregate Operators","permalink":"/docs/explanation/dsl-descriptions"}}');var o=n(4848),s=n(8453);const a={title:"Levels of Abstraction in Aggregate Programming",sidebar_position:2},r=void 0,l={},c=[{value:"Levels of Abstraction in Aggregate Programming",id:"levels-of-abstraction-in-aggregate-programming",level:2},{value:"Field Calculus Constructs",id:"field-calculus-constructs",level:3},{value:"Resilient Coordination Operators",id:"resilient-coordination-operators",level:3},{value:"Developer APIs",id:"developer-apis",level:3},{value:"Example: Gradient Computation",id:"example-gradient-computation",level:4}];function d(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"levels-of-abstraction-in-aggregate-programming",children:"Levels of Abstraction in Aggregate Programming"}),"\n",(0,o.jsx)(t.p,{children:"Through multiple levels of abstraction, aggregate programming mitigates the complexity involved in distributed coordination within IoT network environments:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Aggregated levels of abstraction in aggregate programming",src:n(4463).A+"",width:"1138",height:"796"})}),"\n",(0,o.jsx)(t.h3,{id:"field-calculus-constructs",children:"Field Calculus Constructs"}),"\n",(0,o.jsx)(t.p,{children:"This layer represents the interface where aggregate programming interacts with the external environment. It is composed of device infrastructure and non-aggregated software services, which together form the system's lowest layer. As depicted in the figure, this is the second layer from the bottom."}),"\n",(0,o.jsxs)(t.p,{children:["A key abstraction provided by ",(0,o.jsx)(t.strong,{children:"Field Calculus"})," is the notion of a ",(0,o.jsx)(t.em,{children:"field"}),", inspired by physical phenomena."]}),"\n",(0,o.jsx)(t.p,{children:"In this abstraction, each networked device contributes a local value, forming a distributed structure over the system."}),"\n",(0,o.jsx)(t.p,{children:"For example, temperature sensors might define a field of ambient temperature values, while smartphones might contribute fields of movement directions or displayed notifications."}),"\n",(0,o.jsx)(t.p,{children:"Field manipulation and creation rely on fundamental constructs that enable:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Computation over distributed data"}),": functions allow the execution of operations on data distributed across the system, including both built-in and user-defined logic. These computations can represent readings from sensors or outputs to actuators."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"State evolution over time"}),": mechanisms are provided to model how a device's local state evolves, based on previous states and new inputs from the environment or the system."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Interaction with neighbors"}),": constructs enable devices to collect and aggregate information from neighboring devices, supporting spatial computations like detecting the closest node or propagating values across the network. Notably, value propagation requires a combination of state management mechanisms (for maintaining state across computation rounds) and neighbor interaction constructs (for accessing neighbors' values), enabling the definition of distributed algorithms such as gradient formation or information spreading."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Conditional branching in the network"}),": conditional mechanisms allow devices to behave differently based on local or global conditions, partitioning the network into distinct regions that execute different operations."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Together, these constructs enable the creation of robust and flexible behaviors that emerge from the aggregation of local device interactions and computations."}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.h3,{id:"resilient-coordination-operators",children:"Resilient Coordination Operators"}),"\n",(0,o.jsxs)(t.p,{children:["The next level of abstraction introduces a set of ",(0,o.jsx)(t.strong,{children:"resilient coordination operators"})," designed for robust distributed computations."]}),"\n",(0,o.jsx)(t.p,{children:"These operators enable the system to adapt reactively to changes in network structure or input values, ensuring self-stabilization and resilience."}),"\n",(0,o.jsx)(t.p,{children:"Key operators include:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Gradient formation and value propagation"}),": operations that calculate distance fields and propagate values across the network based on these gradients. These operators are crucial for tasks like broadcasting, projection, or region-based computations, where spatial relationships between nodes are important."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Cumulative information gathering"}),": mechanisms for aggregating information along gradients, such as summing values or collecting information towards specific regions of interest."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Flexible temporal decay"}),": constructs that manage countdown processes or decay functions, enabling time-based coordination that adapts to changing rates or conditions."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"These operators abstract common coordination patterns, simplifying the development of distributed applications by allowing developers to focus on high-level behavior and global objectives, rather than low-level implementation details."}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.h3,{id:"developer-apis",children:"Developer APIs"}),"\n",(0,o.jsxs)(t.p,{children:["Libraries developed using fundamental operators can leverage and combine these operators to create a pragmatic and user-friendly ",(0,o.jsx)(t.strong,{children:"API"})," (Application Programming Interface). These libraries represent the penultimate layer in the structure illustrated in the figure, on which application code is based."]}),"\n",(0,o.jsx)(t.p,{children:"Many distributed actions and information diffusion processes can be abstracted into high-level API functions that encapsulate the complexity of the underlying coordination logic."}),"\n",(0,o.jsx)(t.h4,{id:"example-gradient-computation",children:"Example: Gradient Computation"}),"\n",(0,o.jsxs)(t.p,{children:["The following example demonstrates a simple API function for computing a ",(0,o.jsx)(t.strong,{children:"distance gradient"}),". This function calculates the minimum distance from a set of source devices within a dynamic network. Gradients are a foundational construct in aggregate programming, enabling behaviors like distance estimation and value propagation."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Note"}),": when defining new aggregate functions, it is recommended to use extension functions on the aggregate interface. This promotes reusability and consistency as follows:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-kotlin",children:"fun Aggregate<Int>.gradient(distanceSensor: DistanceSensor, source: Boolean): Double =\n    share(POSITIVE_INFINITY) {\n        val dist = distances()\n        when {\n            source -> 0.0\n            else -> (it + dist).min(POSITIVE_INFINITY)\n        }\n    }\n"})}),"\n",(0,o.jsx)(t.p,{children:"These APIs enable developers to implement sophisticated behaviors within dynamic networks without needing to delve into the low-level details of aggregate computations."})]})}function g(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},4463:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/multiple-levels-of-abstraction-ag-409b85b6e9cccbba522802b48ad0492e.png"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);